
'use client';

import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useEffect, useState, useRef, useCallback } from 'react';
import { auth } from '@/lib/firebase';
import { useAuthState } from 'react-firebase-hooks/auth';
import { Skeleton } from '@/components/ui/skeleton';
import { useRouter } from 'next/navigation';
import { useToast } from '@/hooks/use-toast';
import { Icons } from '@/components/icons';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Bot, Send, User, Check, RefreshCcw } from 'lucide-react';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Label } from '@/components/ui/label';
import { Checkbox } from '@/components/ui/checkbox';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { useSecureFetch } from '@/hooks/use-secure-fetch';
import type { Timestamp } from "firebase/firestore";
import { useSecureFetch } from "@/lib/use-secure-fetch";


type Ticket = {
  id: string;
  subjectName: string;
  reportType: string;
  status: string;
  createdAt: string;
  description: string;
  clientEmail: string;
  endUserId: string;
  formId?: string;
  suggestedQuestions?: string[];
  formSubmittedAt?: string;
};

type Message = {
    role: 'user' | 'model';
    text: string;
}

export default function FormPage({ params }: { params: { ticketId: string }}) {
  const [user, loadingAuth, authError] = useAuthState(auth);
  const [ticket, setTicket] = useState<Ticket | null>(null);
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const router = useRouter();
  const { toast } = useToast();
  const secureFetch = useSecureFetch();
  
  const [formMode, setFormMode] = useState<'ai' | 'manual'>('ai');

  // AI Chat state
  const [history, setHistory] = useState<Message[]>([]);
  const [prompt, setPrompt] = useState('');
  const [isAiThinking, setIsAiThinking] = useState(false);
  const [isFormComplete, setIsFormComplete] = useState(false);
  const [isAgreed, setIsAgreed] = useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  
  // Selfie state
  const [hasCameraPermission, setHasCameraPermission] = useState<boolean | null>(null);
  const videoRef = useRef<HTMLVideoElement>(null);

  const getTicketData = useCallback(async (userId: string) => {
      setLoading(true);
      try {
        const res = await secureFetch(`/api/tickets/${params.ticketId}`);
        const data = await res.json();
        
        if (data.error) throw new Error(data.error);
        const ticketData = data.ticket as Ticket;

        if (ticketData.endUserId !== userId) {
          toast({
            title: 'Access Denied',
            description: 'You do not have permission to view this form.',
            variant: 'destructive',
          });
          setTicket(null);
        } else if (ticketData.status !== 'New' && ticketData.status !== 'In Progress') {
            setTicket(ticketData); 
        } else {
          let questions = ticketData.suggestedQuestions || [];
          if (ticketData.formId) {
            const formRes = await secureFetch(`/api/forms/${ticketData.formId}`);
            const formData = await formRes.json();
            if (formData.form && formData.form.fields) {
                const fieldIds = formData.form.fields;
                if (fieldIds.length > 0) {
                    const fieldsRes = await secureFetch(`/api/fields?ids=${fieldIds.join(',')}`);
                    const fieldsData = await fieldsRes.json();
                    questions = fieldsData.fields.map((d: any) => d.label);
                }
            }
          }
          const finalTicketData = { ...ticketData, suggestedQuestions: questions };
          setTicket(finalTicketData);
          
          if (history.length === 0 && formMode === 'ai') {
            handleSend(true, finalTicketData);
          }
        }
      } catch (err: any) {
        toast({ title: 'Not Found', description: err.message, variant: 'destructive'});
        setTicket(null);
      } finally {
        setLoading(false);
      }
    }, [params.ticketId, toast, secureFetch, formMode, history.length]);


